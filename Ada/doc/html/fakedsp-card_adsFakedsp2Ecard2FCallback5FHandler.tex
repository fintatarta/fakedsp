% Document: ./src/fakelib/fakedsp-card.ads
% Source: ./src/fakelib/fakedsp-card.ads
% Generated with ROBODoc Version 4.99.43 (Apr  5 2019)
\documentclass{article}
\usepackage{makeidx}
\usepackage{graphicx}
\oddsidemargin 0.25 in 
\evensidemargin 0.25 in
\marginparwidth 0.75 in
\textwidth 5.875 in
\setlength{\parindent}{0in}
\setlength{\parskip}{.08in}

\pagestyle{headings}
\title{FakeDSP API}
\author{Generated with ROBODoc Version 4.99.43 (Apr  5 2019)
}
\makeindex
\begin{document}
\maketitle
\printindex
\tableofcontents
\newpage

<a class="menuitem" href="./fakedsp-card_adsFakedsp2FFakedsp2Ecard.tex#robo22">Fakedsp.card</a><a class="menuitem" href="./robo_interfaces.tex#robo_top_of_doc">Abstract Interfaces</a>\subsection{Fakedsp.card/Callback\_Handler}
\index{unsorted!Callback\_Handler}\index{Abstract Interfaces!Callback\_Handler}
\textbf{SOURCE:}\hspace{0.08in}\begin{verbatim}
   type Callback_Handler is interface;
   
   procedure Sample_Ready (H : in out Callback_Handler) is abstract;
\end{verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}
   A Callback\_Handler defines an interface similar to that of 
   an interrupt handler.



   A concrete implementation of interface Callback\_Handler is just 
   required to define a procedure Sample\_Ready (\ref{ch:robo0}) that
   will be called when a new sample from the ADC is ready to be 
   acquired.



   Why an object rather than a simple callback?  Because an object
   can carry a state.  For example, if the handler implements some
   filter it needs to keep the past story of the signal and this
   would be more cumbersome with a simple callback. 


\end{document}
